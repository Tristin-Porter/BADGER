# x86_64 Architecture

## Overview

x86_64 (also known as x64, AMD64) is the primary and most thoroughly tested architecture in BADGER. It is a 64-bit extension of the x86 instruction set.

## Register Set

### General Purpose Registers (64-bit)
- `rax`, `rbx`, `rcx`, `rdx` - Traditional accumulator, base, count, data registers
- `rsi`, `rdi` - Source and destination index registers
- `rbp`, `rsp` - Base pointer and stack pointer
- `r8` through `r15` - Additional 64-bit registers

### Stack Simulation Registers
BADGER uses specific registers to simulate the WAT stack:
- `r12` - Stack slot 0 (top of stack)
- `r13` - Stack slot 1
- `r14` - Stack slot 2
- `r15` - Stack slot 3
- `[rbp - N]` - Spilled values (stack overflow)

### Special Purpose Registers
- `r11` - Memory base register (holds linear memory base address)
- `rbp` - Frame pointer
- `rsp` - Stack pointer

## Calling Convention

BADGER uses a simplified stack-based calling convention:

### Prologue
```asm
push rbp          ; Save old base pointer
mov rbp, rsp      ; Set up new frame
; Allocate space for locals and spills
```

### Epilogue
```asm
mov rsp, rbp      ; Restore stack pointer
pop rbp           ; Restore base pointer
ret               ; Return to caller
```

## Instruction Subset

BADGER supports a canonical subset of x86_64 instructions:

### Data Movement
- `mov reg, reg` - Register to register move
- `mov reg, imm` - Immediate to register
- `mov reg, [mem]` - Memory to register
- `mov [mem], reg` - Register to memory

### Arithmetic
- `add reg, reg` - Addition
- `sub reg, reg` - Subtraction
- `imul reg, reg` - Signed multiplication
- `idiv reg` - Signed division (uses rax/rdx)

### Logical
- `and reg, reg` - Bitwise AND
- `or reg, reg` - Bitwise OR
- `xor reg, reg` - Bitwise XOR
- `not reg` - Bitwise NOT

### Comparison and Testing
- `cmp reg, reg` - Compare (sets flags)
- `test reg, reg` - Test (bitwise AND, sets flags)

### Control Flow
- `jmp label` - Unconditional jump
- `je label` - Jump if equal
- `jne label` - Jump if not equal
- `jl label` - Jump if less (signed)
- `jg label` - Jump if greater (signed)
- `jle label` - Jump if less or equal (signed)
- `jge label` - Jump if greater or equal (signed)

### Function Calls
- `call label` - Call function
- `ret` - Return from function

### Stack Operations
- `push reg` - Push register onto stack
- `pop reg` - Pop from stack into register

## Instruction Encoding

x86_64 uses variable-length instruction encoding:

### REX Prefix (0x40 - 0x4F)
Required for:
- 64-bit operand size (REX.W = 1)
- Accessing r8-r15 registers
- Accessing extended register bytes

Format: `0100WRXB`
- W: 64-bit operand size
- R: ModRM reg field extension
- X: SIB index field extension
- B: ModRM r/m field extension

### Opcode (1-3 bytes)
Main instruction identifier

### ModRM Byte (optional)
Format: `MMRRRMMM`
- MM: Mode (register, memory, displacement)
- RRR: Register or opcode extension
- MMM: R/M (register or memory)

### SIB Byte (optional)
For complex addressing modes:
Format: `SSIIIBBB`
- SS: Scale (1, 2, 4, 8)
- III: Index register
- BBB: Base register

### Displacement (0, 1, 2, or 4 bytes)
Memory offset

### Immediate (0, 1, 2, 4, or 8 bytes)
Immediate value

## Example Encodings

### push rbp
```
55                ; Opcode for push rbp
```

### mov rax, rbx
```
48 89 D8          ; REX.W + MOV r/m64, r64 + ModRM(rax, rbx)
```

### add rax, 42
```
48 83 C0 2A       ; REX.W + ADD r/m64, imm8 + ModRM(rax) + immediate(42)
```

### ret
```
C3                ; Near return
```

## Memory Addressing

x86_64 supports complex addressing modes:

### Direct Register
```asm
mov rax, rbx      ; Register direct
```

### Immediate
```asm
mov rax, 42       ; Immediate value
```

### Memory Indirect
```asm
mov rax, [rbx]    ; Load from address in rbx
```

### Memory with Displacement
```asm
mov rax, [rbp-8]  ; Load from rbp - 8
```

### Scaled Index (SIB)
```asm
mov rax, [rbx + rcx*4 + 8]  ; Complex addressing
```

## WAT Lowering Examples

### i32.const 42
```asm
mov r12, 42       ; Load immediate into stack top
```

### i32.add
```asm
add r12, r13      ; Add second stack value to top
; Stack shrinks by 1
```

### local.get 0
```asm
mov rax, [rbp-16] ; Load local from stack frame
; Push to stack (r12)
mov r12, rax
```

## Testing

x86_64 tests verify:
- All instruction encodings match expected bytes
- REX prefix generation
- ModRM byte calculation
- Immediate encoding
- Label resolution and branch offsets

See: `Testing/AssemblyEncodingTests.cs` for specific test cases.
