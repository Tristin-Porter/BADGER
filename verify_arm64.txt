ARM64 Assembler Verification Test
==================================

Test 1: Basic Instructions
---------------------------
Input:
    ret
    nop
    
Expected: 8 bytes (2 instructions × 4 bytes)
Encoding:
    C0 03 5F D6  (RET)
    1F 20 03 D5  (NOP)

Test 2: Arithmetic with Registers
-----------------------------------
Input:
    mov x0, #42
    mov x1, #100
    add x2, x0, x1
    sub x3, x2, x0
    mul x4, x1, x2
    
Expected: 20 bytes (5 instructions × 4 bytes)

Test 3: Branches and Labels
-----------------------------
Input:
    start:
        mov x0, #1
        cmp x0, #1
        b.eq done
        mov x0, #2
    done:
        ret
        
Expected: 20 bytes (5 instructions × 4 bytes)
Features: Label resolution, PC-relative addressing

Test 4: Function Prologue/Epilogue
------------------------------------
Input:
    function:
        stp x29, x30, [sp, #-16]!
        mov x29, sp
        sub sp, sp, #32
        mov sp, x29
        ldp x29, x30, [sp], #16
        ret
        
Expected: 24 bytes (6 instructions × 4 bytes)
Features: Stack operations, frame management

Test 5: Load/Store Operations
-------------------------------
Input:
    str w0, [sp, #-4]!
    ldr w0, [sp], #4
    
Expected: 8 bytes (2 instructions × 4 bytes)
Features: Pre-index and post-index addressing

All Features Implemented:
✓ Two-pass assembly with label collection
✓ Fixed 32-bit little-endian instructions
✓ PC-relative branch addressing
✓ 64-bit and 32-bit register operations
✓ Pre/post-index addressing modes
✓ Immediate operands
✓ Conditional branches
✓ Branch with link (function calls)
✓ Load/store pairs
✓ Input validation with range checking
✓ Thread-safe implementation
✓ Comprehensive error messages
